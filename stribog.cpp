#include <string.h>

#include "stribog_constants.hpp"
#include "stribog.hpp"

static inline void add_512(const unsigned char* lop, const unsigned char* rop, unsigned char* result)
{
    unsigned char cf = 0; //carrier flag
    for (int i = 63; i >= 0; --i){
        result[i]=lop[i]+rop[i]+cf;
        cf = (result[i] < lop[i]) || (result[i] < rop[i]);
    }
}


static inline void xor_512(const unsigned char* lop, const unsigned char* rop, unsigned char* result)
{
    for(int i = 0; i < 64; ++i)
    {
        result[i] = lop[i] ^ rop[i];
    }
}

static inline void add_int_mod512(unsigned char* srcdest, unsigned int num)
{
    unsigned char shifted = num & 0XFF;
    srcdest[63] += shifted;
    unsigned char cf = srcdest[63] < shifted;

    shifted = (num >> 1*8) & 0XFF;
    srcdest[62] += shifted + cf;
    cf = srcdest[62] < shifted;

    shifted = (num >> 2*8) & 0XFF;
    srcdest[61] += shifted + cf;
    cf = srcdest[61] < shifted;

    shifted = (num >> 3*8) & 0XFF;
    srcdest[60] += shifted + cf;
    cf = srcdest[60] < shifted;

    for(int i = 59; i >= 0 && cf; --i){
        srcdest[i] += cf;
        cf = (srcdest[i]==0);
    }
}

static inline void P(unsigned char* state)
{
    //though it uses tau permutation in standart, it just transposes state 8x8 matrix

    unsigned char temp[64];

    int row, column;
    for(row = 0; row < 8; ++row)
        temp[row*9]=state[row*9];

    for(row = 0; row < 8; ++row)
        for(column = row + 1; column < 8; column++){
            temp[8*row+column] = state[8*column+row];
            temp[8*column+row] = state[8*row+column];
        }

    memcpy(state, temp, 64);
}

static inline void S(unsigned char* state)
{
    for(int i = 0; i < 64; ++i)
        state[i]=stable[state[i]];
}

static inline void L(unsigned char* state)
{
    for(int k = 0; k < 8; ++k){ //64 bytes divided into 8 groups
        unsigned long long xored_vector = 0; //64 bits
        for(int i = 0; i < 8; ++i){ //index for each char in group
            for(int j = 0; j < 8; ++j){ //index for each bit in char
                if(state[8*k+i] & (1 << (7-j)))
                    xored_vector ^= larray[8*i+j];
            }
        }
        for(int i = 0; i < 8; ++i){
            state[k*8+i] = (unsigned char)((((unsigned long long) 0xFF << ((7-i)*8)) & xored_vector) >> ((7-i)*8));
        }
    }
}

static void get_round_key(unsigned char* K, int i)
{
    xor_512(K, C[i-2], K);

    S(K);
    P(K);
    L(K);
}

void E(const unsigned char* h, const unsigned char* N, const unsigned char* m, unsigned char* out)
{
    unsigned char K[64];
    xor_512(h, N, K);
    S(K);
    P(K);
    L(K);
    //we have K1

    xor_512(K, m, out);
    S(out);
    P(out);
    L(out);

    for(int i = 2; i <= 12; ++i){
        get_round_key(K, i);

        xor_512(K, out, out);
        S(out);
        P(out);
        L(out);
    }

    get_round_key(K, 13);
    xor_512(K, out, out);

}

static void g(const unsigned char* h, const unsigned char* m, const unsigned char* N, unsigned char* out)
{
    E(h, N, m, out);
    xor_512(out, h, out);
    xor_512(out, m, out);
}


static void stage2(unsigned char* m, unsigned char* h, unsigned char* N, unsigned char* Sigma)
{
    unsigned char temp[64];

    g(h, m, N, temp);

    add_int_mod512(N, 512);
    add_512(Sigma, m, Sigma);

    memcpy(h, temp, 64);
}

void hash_computing(const unsigned char* message, unsigned long long length, unsigned char* h)
{
    unsigned char N[64] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };

    unsigned char Sigma[64] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };

    const unsigned char null_vector[64] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };



    unsigned long long k = length; //TODO: rename this - that's a length of uncomputed block
    unsigned char temp2[64];
    while(!(k < 64)){ //512 bits / 8
        k -= 64;
        memcpy(temp2, message+k,64);
        stage2(temp2, h, N, Sigma);
    }

    //now we have only 0..63 bytes of message

    memcpy(temp2+64-k, message, k);
    temp2[64-k-1]=0x01;
    //TODO:replace by memcpy
    for(unsigned int i = 0; i < 64-k-1; ++i)
        temp2[i]=0x00;

    unsigned char stage3h[64] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };

    g(h, temp2, N, stage3h);
    add_int_mod512(N, (unsigned int)(k*8));

    add_512(Sigma, temp2, Sigma); //TODO: REWRIRE IT PLEASE WHY h and stage3h always converted (because i wanted that)

    g(stage3h, N, null_vector, h);

    g(h, Sigma, null_vector, stage3h);

    memcpy(h, stage3h, 64);
}

void hash_512(const unsigned char* message, unsigned long long length, unsigned char out[512])
{
    unsigned char h[64] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };

    hash_computing(message, length, h);
    memcpy(out, h, 64);
}
void hash_256(const unsigned char* message, unsigned long long length, unsigned char out[256])
{
    unsigned char h[64] = {
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    };

    hash_computing(message, length, h);
    memcpy(out, h, 32);
}
